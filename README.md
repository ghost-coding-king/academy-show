# 전국학원자랑 (진행중)

## 프로젝트 개요
소도시일수록 교육정보에 대한 불균형이 큽니다.

'전국학원자랑'은 그것을 코딩으로 해결하는 과정을 경험해보고자 시작한 프로젝트입니다.

웹 서비스를 통해 학원 및 과외를 홍보하거나 정보를 찾을 수 있고, 리뷰와 교육정보들을 확인할 수 있습니다.

<br>

백엔드 서버(API)와 클라이언트(Vue.js)로 구성되어 있습니다.

<br>

## Frameworks

<img src="https://img.shields.io/badge/Spring Boot-6DB33F?style=flat-square&logo=Spring Boot&logoColor=white"/> <img src="https://img.shields.io/badge/Vue.js-4FC08D?style=flat-square&logo=Vue.js&logoColor=white"/> 


## IDE

<img alt="" src ="https://img.shields.io/badge/VSCode-007ACC.svg?&style=flat&logo=Visual Studio Code&logoColor=white"/> <img alt="" src ="https://img.shields.io/badge/IntelliJ-000000.svg?&style=flat&logo=IntelliJ IDEA&logoColor=white"/>

## TECHS
### JWT 기반의 사용자 인증
JWT(JSON WEB TOKEN)는 정보를 JSON을 사용하여 안전하게(손상, 위조여부 확인) 통신하기 위한 개방된 표준입니다. JWT는 웹 애플리케이션에서 인증 및 권한 부여 목적으로 자주 사용되고 있습니다.

JWT는 헤더, 페이로드, 서명의 세 부분으로 구성됩니다. 헤더는 토큰의 유형과 서명에 사용되는 알고리즘을 정의합니다. 페이로드에는 사용자와 관련된 정보와 추가로 필요로 하는 데이터들이 포함됩니다. JWT의 서명은 헤더와 페이로드정보를 기반으로 비밀키를 사용하여 생성됩니다. 이후 수신자가 헤더와 페이로드정보를 기반으로 비밀키를 사용하여 서명을 만든후 jwt토큰의 서명과 비교해보면 위조여부를 확인할수 있습니다.

#### 로컬 계정 인증플로우
![Github_Logo](./docs/jwt-workflow1.png)  

#### 소셜 계정 (네이버) 사용시, 토큰과 분리된 프론트엔드(리액트, 뷰...) 에서의 jwt 인증플로우
![Github_Logo](./docs/jwt-workflow2.png)
- 먼저 백엔드의 소셜로그인을 위한 API로 요청을 보냅니다.
- 향후 백엔드에서 토큰발행후 원래의 프론트로 리다이렉트 할수 있도록 쿠키 설정 (authorizationRequestRepository)
- 서비스 프로바이더로 리다이렉트되어 소셜로그인 진행
- 소셜로그인 성공시 백엔드로 리다이렉트후 토큰 발행
- 토큰 정보와 함께 프론트로 다시 리다이렉트
- profit!

#### JWT의 특징
- JWT는 Stateless 합니다. 인증에 필요한 모든 정보를 토큰에 자체적으로 저장할수 있고, 서명으로 이를 검증할수 있으므로 데이터베이스 요청없이 인증이 가능합니다. 따라서 시스템 아키텍처를 단순화하고 서버의 부하를 줄일 수 있습니다. 다만 토큰이 한번 발행되면 토큰을 무력화시킬수 없으므로 취약점이 있습니다.
- JWT는 인증/인가 서버를 넘어서서 어떤 서버에서도 처리와 생성이 가능하므로 탈중앙화된 특징이 있어서 마이크로서비스에 유리합니다.
- JWT는 JSON 이고, 이를 지원하는 언어와 라이브러리가 많아서 범용성이 높습니다. (웹, 앱 등등등)
- JWT는 페이로드의 용량제한이 없습니다. 이는 장단점으로 작용할수 있습니다.

#### Stateless 한 JWT의 단점 보완방법
- access token과 refresh token 분리
전국학원자랑에 적용된 access token과 refresh token을 분리하여 운영하는 방법이 있습니다. 엑세스 토큰은 필요한 비즈니스 요청을 할때 사용하고, 리프레시 토큰은 엑세스 토큰의 재발행을 위해 사용합니다. 이를 위해 클라이언트가 사용자 이름 및 비밀번호와 같은 자격 증명을 제공하여 서버에 로그인 요청을 보내면, 서버는 자격 증명의 유효성을 검사하고 유효한 경우 액세스 토큰과 새로 고침 토큰의 두가지 토큰을 클라이언트에 발행합니다.

일반적으로 액세스 토큰은 수명이 짧고 리프레시 토큰은 수명이 깁니다. 이를 통해 엑세스 토큰이 유출되더라도 유효기간이 짧아서 리스크를 줄일수 있습니다.
또한 리프레시 요청시 엑세스토큰은 헤더에 Authorization 키로 설정하고 리프레시토큰은 쿠키로 설정하여 요청하도록 구현했습니다. 두종류의 토큰이 모두 있어야만 리프레시 요청이 가능하므로, csrf와 xss 공격에 대해 동시에 보완을 해보려 노력했습니다. 또한 리프레시 토큰은 데이터베이스에서 관리하므로, 리프레시 토큰이 탈취되거나 해당 유저가 부정을 저지르면 데이터베이스 레벨 에서 토큰을 무효화시킬수 있도록 구현했습니다.

- refresh token 은 세션으로 관리
refresh token을 데이터베이스등의 방법으로 세션으로 관리하는 방법이 있습니다. 부정사용이 확인시 refresh token을 세션에서 삭제, 무효화하여, access token의 재발행을 방지할수 있습니다. 예를들어 refresh token과 접속 ip를 서버의 세션에 저장하고, refresh token을 통한 access token 갱신 요청이 다른 ip로부터 온다면 비정상적인 접근으로 판단하여 무효화시키는 방법이 있습니다.

- RTR (Refresh Token Rotation)
Refresh Token을 한번만 사용할 수 있게(One Time Use Only) 만드는 방법입니다. Refresh Token을 사용하여 새로운 Access Token을 발급받을 때 Refresh Token 도 새롭게 발급받을수 있습니다.

이런 방식을 사용하면, 이미 사용된 Refresh Token을 사용할수 없고, 또한 서비스측에서 탈취를 확인하여 해당 계정에 대한 추가적인 조치를 할 수 있게 됩니다. 다만, 사용되지 않은 Refresh Token을 훔쳐 사용하거나, 그냥 지속적인 Access Token 탈취는 막을수 없습니다.

#### API Gateway 패턴
마이크로서비스 환경에서 모든 서비스에 접근하기 위한 하나의 엔드포인트를 제공하기 위해 API 게이트웨이를 사용합니다. 따라서 API 게이트웨이에서 각각의 서비스의 공통된 로직을 처리할수 있으므로 인증을 처리하기에 유리합니다. 따라서 API 게이트웨이와 클라이언트간에는 세션인증을 사용하고, 게이트웨이와 서비스들간에는 jwt를 사용하면 두 방법의 장점을 모두 살릴수 있습니다. 다만 규모가 큰 MSA환경에 유리하다는 단점이 있습니다.

#### 쿠키-세션 인증 과 jwt기반 인증의 비교
쿠키-세션은 웹브라우저의 지원을 받아 구현이 간편한 장점이 있습니다. 세션을 통해 부정한 요청발생시 바로 차단을 할수 있지만, 쿠키를 통해 세션을 확인하는 만큼 csrf 공격에 취약합니다. 쿠키는 웹브라우저에 종속된 기술이기 때문에 안드로이드, 아이폰 앱등의 다양한 생태계로의 확장성이 부족한 특징이 있습니다. 주로 중앙화된 어플리케이션(단일 소스코드로 구성된 모놀리식 아키텍처), 사용자를 예측하기 힘든 신규 서비스, 규모가 작은 어플리케이션에 적합합니다.

jwt기반 인증은 stateless 하므로 꼭 인증 서버가 아니더라도 토큰을 처리할수 있으므로 탈중앙화에 유리합니다. 또한 토큰을 처리하기 위해 세션을 검색하는것이 아니라 어플리케이션 단에서 서명을 검증하므로 서버의 성능향상에 도움이 됩니다. 따라서 규모가 큰 어플리케이션, 마이크로서비스 아키텍쳐 기반의 어플리케이션에 적합합니다.

### 좋아요 갯수 집계를 위한 배치 도입
#### BATCH?
배치(일괄처리)는 주기적으로 많은 수의 데이터에 대한 작업 또는 작업을 하나의 프로세스로 실행하는 것을 말합니다. 일반적으로 작업의 효율성과 성능을 개선하고 필요한 수동 개입의 양을 줄이기 위해 수행됩니다. 배치는 데이터 처리, 금융 거래, 시스템 유지 관리, 백업, 집계, 보고서 생성 등 다양한 애플리케이션에서 일반적으로 사용됩니다.

#### 좋아요 갯수로 정렬시 발생했던 문제
'전국학원자랑' 서비스는 학원이나 과외등의 정보를 좋아요 갯수순으로 정렬하여 반환해주는 기능이 있습니다. 그런데 예를들어 학원을 좋아요 갯수순으로 정렬하기 위해선, 학원 테이블과 좋아요 테이블의 조인, groupby 연산이필요합니다. 시간복잡도는 O(N*M) 이 되어 시간이 오래걸릴수 있다는 생각이 들었습니다. 이문제를 보완하는 방법은 여러가지가 있었습니다.

- join시 성능향상을 위한 인덱스 생성 
	+ 정렬 시간복잡도를 O(N*logM)에 할수 있습니다.
- 좋아요갯수를 정해진 시간에 집계한 값을 이용해 정렬에 활용 (O)
	+ 정렬 시간복잡도를 O(N)에 할수 있습니다.
	+ 하지만 좋아요 갯수를 실시간으로 반영할수 없는 단점이 있습니다.
- 좋아요 갯수를 저장하는 칼럼을 따로 두고, 좋아요시 트랜잭션 레벨을 SERIALIZABLE 로 설정하거나, select for update 사용
	+ 좋아요갯수를 실시간으로 반영할수 있지만 병행성이 떨어지는 문제가 있습니다.
- 좋아요 갯수를 저장하는 칼럼을 사용하되 일반적인 트랜잭션 레벨 사용
	+ 정렬은 빠르지만 정확한 좋아요 갯수를 보장하지 못합니다.

실무에서도 이런 상황이 발생한다면 어떻게 구현하는것이 좋을까요? 비즈니스 에서 실시간으로 정확한 갯수를 요구하는지 여부가 중요할것 같습니다.
저는 초기에는 인덱스만 생성하여 그때그때 마다 집계하여 정렬하고, 이후 '전국학원자랑'의 규모가 커지면(아마 각각의 좋아요갯수가 만단위가 넘어가면...) 배치로직을 도입하는것이 좋다고 생각하고 있습니다. 만약 좋아요가 아니라 이커머스상에서의 재고라면 어떨까요? 재고의 갯수를 배치를 통해 집계하는것은 실시간으로 정확한 재고의 갯수를 알수 없기 때문에 부적절해보입니다. 저는 일단 배치 사용 연습을 위해 정해진 시간마다 좋아요 갯수를 집계하는 방법을 사용해봤습니다.

#### 배치과정
- 집계된 좋아요 갯수를 저장하는 테이블(BatchLike)의 값들을 전부 0으로 초기화한다.
- 좋아요 테이블을 순회하면서 BatchLike 테이블의 값을 증가시키면서 집계한다.

